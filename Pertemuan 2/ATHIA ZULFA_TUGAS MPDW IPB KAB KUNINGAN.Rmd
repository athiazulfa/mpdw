---
title: "TUGAS MPDW IPM KAB.KUNINGAN 2004-2013"
author: "ATHIA ZULFA"
date: "2025-09-02"
output: html_document
---

### **Tahap 1: Persiapan Alat dan Data**
#### Persiapan Package dan Data
Langkah pertama adalah memastikan semua package yang kita butuhkan sudah ter-install dan siap digunakan.

```{r}
# Setelah instalasi berhasil, panggil semua library
library(lmtest) # Untuk Uji Durbin-Watson
library(orcutt) # Untuk metode Cochrane-Orcutt
library(HoRM)   # Untuk metode Hildreth-Lu

```
Secara sederhana, autokorelasi berarti error (sisaan) dari satu periode “menulari” error di periode berikutnya. Jika ada autokorelasi, kesimpulan dari model regresi kita (seperti uji-t dan uji-F) menjadi tidak valid dan tidak bisa dipercaya.

### **Input Data**
```{r}
# Input Data IPM Indramayu (2004-2013)
tahun <- 2004:2013
ipm <- c(67.70, 68.53, 69.21, 69.70, 70.12, 70.42, 70.89, 71.55, 71.99, 72.47)
dt_ipm <- data.frame(tahun, ipm)

# Lihat datanya
print(dt_ipm)
```
```{r}
plot(ts(ipm))
points(ipm, col="red")

```

### **Tahap 2: Membuat Model Awal**
Membuat model regresi linear sederhana untuk memprediksi `IPM di Kabupaten Kuningan` berdasarkan `tahun`.
```{r}
# Membuat model regresi OLS (Ordinary Least Squares)
model_awal <- lm(ipm ~ tahun, data = dt_ipm)
summary(model_awal)
```


### **Tahap 3: Diagnosis (Investigasi Sisaan)**

Sekarang kita akan memeriksa **sisaan (residuals)** dari model kita. 

### *3.1. Diagnosis Visual*

Kita akan membuat plot sisaan untuk melihat apakah ada pola yang mencurigakan.
```{r}
# Ambil sisaan dari model
sisaan_awal <- residuals(model_awal)

# Plot sisaan terhadap waktu
plot(dt_ipm$tahun, sisaan_awal, type="o", pch=20, col="red",
     main="Plot Sisaan vs Waktu", xlab="Tahun", ylab="Sisaan")
abline(h=0, lty=2) # Garis referensi di y=0
```

Plot di atas menunjukkan pola yang **tidak acak**. Perhatikan bagaimana sisaan cenderung berkelompok: titik pertama di bawah nol, lalu naik ke atas nol, dan turun lagi. Ini adalah gejala visual yang kuat dari autokorelasi positif. Sisaan positif cenderung diikuti sisaan positif, dan sebaliknya.

### *3.2. Diagnosis Formal (Uji Durbin-Watson)*

Untuk uji formal, kita gunakan Uji Durbin-Watson.

- **H0 (Hipotesis Nol)**: Tidak ada autokorelasi. Sisaan saling bebas.
- **H1 (Hipotesis Alternatif)**: Ada autokorelasi.
```{r}
dwtest(model_awal)
```
- P-value yang dihasilkan **(0.01238)**, yaitu di bawah tingkat signifikansi 0.05.
- Kesimpulan: Kita **tolak H0**. Bukti sudah kuat. Model kita **terbukti menderita autokorelasi**.

### **Tahap 4: Penanganan (Menyembuhkan Model)**

Karena model kita "sakit", kita perlu menanganinya. Kita akan coba dua metode.

#### *Metode 1: Cochrane-Orcutt*

Metode ini secara iteratif (berulang-ulang) mencoba menemukan "tingkat penularan" error (disebut rho, ρ), lalu menyesuaikan model sampai autokorelasinya hilang.

1. Teori Singkat: C-O adalah prosedur iteratif untuk mengestimasi koefisien regresi. Intinya adalah:
2. Estimasi koefisien autokorelasi sisaan, rho (ρ).
3. Gunakan ρ untuk mentransformasi variabel dependen (Y) dan independen (X) menjadi:
-   $Y_t^* =Y_t−\rho Y_{t−1}$
-   $X_t =X_t−\rho X_{t−1}$
4. Jalankan regresi OLS pada variabel yang sudah ditransformasi ($Y_t^*$ vs $X_t^*$).
5. Ulangi langkah 1-3 sampai nilai ρ konvergen.

```{r}
model_co <- cochrane.orcutt(model_awal)
summary(model_co)

# rho paling optimum
rho <- model_co$rho
cat("Rho optimum:", rho)
```
**Hasil Penanganan (C-O):**

- Lihat nilai **rho** yang diestimasi. Ini adalah “dosis” yang digunakan untuk memperbaiki model.
- Lihat statistik **Durbin-Watson baru**. Nilainya sekarang jauh lebih dekat ke 2, dan p-value-nya (> 0.05) menunjukkan bahwa **autokorelasi sudah berhasil diatasi**.
- Perhatikan koefisien `(Intercept)` dan `tahun` yang baru. Ini adalah estimasi yang lebih valid.

**Verifikasi Manual:**
```{r}
ipm.trans <- dt_ipm$ipm[-1] - dt_ipm$ipm[-10]*rho

tahun.trans <- dt_ipm$tahun[-1] - dt_ipm$tahun[-10]*rho
model_co_manual <- lm(ipm.trans~tahun.trans)

b0_co_manual <- coef(model_co_manual)[1]/(1-rho)
b1_co_manual <- coef(model_co_manual)[2]
cat("Koefisien manual Cochrane-Orcutt:\n")
cat("b0:", b0_co_manual, "\n")
cat("b1:", b1_co_manual, "\n")
```
Hasil koefisien manual kita sangat mirip dengan hasil dari fungsi otomatis. Ini membuktikan bahwa kita memahami mekanisme di baliknya. (Catatan: Perbedaan kecil mungkin terjadi karena fungsi otomatis melakukan beberapa iterasi).

#### *Metode 2: Hildreth-Lu*
Metode ini lebih sistematis. Ia akan mencoba berbagai kemungkinan nilai ρ dan memilih satu yang menghasilkan **Sum of Squared Errors (SSE) terkecil.**
```{r}
#Penanganan Autokorelasi Hildreth lu
# Hildreth-Lu
hildreth.lu.func<- function(r, model){
  x <- model.matrix(model)[,-1]
  y <- model.response(model.frame(model))
  n <- length(y)
  t <- 2:n
  y <- y[t]-r*y[t-1]
  x <- x[t]-r*x[t-1]
  
  return(lm(y~x))
}

#Pencariab rho yang meminimumkan SSE
r <- c(seq(0.1,0.9, by= 0.1))
tab <- data.frame("rho" = r, "SSE" = sapply(r, function(i){deviance(hildreth.lu.func(i, model_awal))}))
round(tab, 4)
```
Pertama-tama akan dicari di mana kira-kira ρ yang menghasilkan SSE minimum. Pada hasil di atas terlihat ρ minimum ketika 0.3. Namun, hasil tersebut masih kurang teliti sehingga akan dicari kembali ρ yang lebih optimum dengan ketelitian yang lebih. Jika sebelumnya jarak antar ρ yang dicari adalah 0.1, kali ini jarak antar ρ adalah 0.001 dan dilakukan pada selang 0.1 sampai dengan 0.5.
```{r}
#Rho optimal di sekitar 0.5
rOpt <- seq(0.1,0.5, by= 0.001)
tabOpt <- data.frame("rho" = rOpt, "SSE" = sapply(rOpt, function(i){deviance(hildreth.lu.func(i, model_awal))}))
head(tabOpt[order(tabOpt$SSE),])
```
```{r}
#Grafik SSE optimum
par(mfrow = c(1,1))
plot(tab$SSE ~ tab$rho , type = "l", xlab = "Rho", ylab = "SSE")
abline(v = tabOpt[tabOpt$SSE==min(tabOpt$SSE),"rho"], lty = 2, col="red",lwd=2)
text(x=0.286, y=0.05433650, labels = "rho=0.286", cex = 0.8)
```
```{r}
model_hl <- hildreth.lu(dt_ipm$ipm, dt_ipm$tahun, rho = 0.286)
summary(model_hl)
```
```{r}
#Transformasi Balik
cat("y = ", coef(model_hl)[1]/(1-0.286), "+", coef(model_hl)[2],"x", sep = "")
```
```{r}
#Deteksi autokorelasi
dwtest(model_hl)
```
**Hasil Penanganan (H-L):**

- Plot yang dihasilkan secara visual menunjukkan nilai ρ mana yang memiliki SSE terendah.
- Hasil summary memberikan model akhir yang juga sudah “sehat”, dengan statistik D-W yang sudah membaik.

### **Tahap 5: Evaluasi Akhir**
Mari kita bandingkan SSE dan Statistik Durbin-Watson dari ketiga model untuk melihat seberapa efektif penanganan kita.
```{r}
# Menghitung SSE untuk setiap model secara manual
sse_awal <- sum(residuals(model_awal)^2)
sse_co <- sum(residuals(model_co)^2)
sse_hl <- sum(residuals(model_hl)^2)

# Membuat tabel perbandingan
data.frame(
  Metode = c("Model Awal (Sakit)", "Cochrane-Orcutt (Sehat)", "Hildreth-Lu (Sehat)"),
  SSE = c(sse_awal, sse_co, sse_hl),
  DW_Statistic = c(dwtest(model_awal)$statistic, model_co$DW[3], dwtest(model_hl)$statistic)
)

```

**Kesimpulan:**

- Baik metode Cochrane-Orcutt maupun Hildreth-Lu berhasil menurunkan SSE model, artinya model yang baru lebih akurat.
- Keduanya juga berhasil menghilangkan autokorelasi, yang ditunjukkan oleh statistik D-W yang mendekati 2.
- Model akhir yang seharusnya kita gunakan adalah salah satu dari model yang telah ditangani, karena estimasi koefisien dan uji signifikansinya sekarang jauh lebih dapat dipercaya.

Hasil analisis menunjukkan bahwa model awal memiliki masalah autokorelasi yang cukup serius (DW ≈ 1.03). Setelah dilakukan koreksi dengan metode Cochrane-Orcutt dan Hildreth-Lu, nilai Durbin–Watson meningkat menjadi sekitar 1.59, mendekati 2, sehingga masalah autokorelasi berhasil diatasi.

Dari sisi ketepatan model, metode Hildreth-Lu memberikan hasil terbaik karena mampu menurunkan SSE secara signifikan dibandingkan metode lain, sekaligus menjaga kestabilan residual. Dengan demikian, model Hildreth-Lu dapat dipilih sebagai model akhir yang paling sehat dan dapat dipercaya untuk analisis selanjutnya.








